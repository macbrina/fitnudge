"""
FitNudge V2 - Check-ins API Endpoints

Check-ins are the core of FitNudge V2:
- Pre-created daily by Celery task for active goals (status='pending')
- Updated when users respond to notifications (status -> completed/skipped/rest_day)
- Marked as 'missed' at end of day if no response
- Always associated with a goal
- Include mood (for completed) or skip_reason (for skipped)
- AI generates personalized response after each check-in (async for premium)

V2.1 Status Flow:
1. Daily task pre-creates check-ins with status='pending'
2. User receives push notification at reminder time
3. User taps Yes âœ“ / No âœ— / Rest Day ðŸ’¤
4. Check-in status updated via POST /check-ins (pending -> completed/skipped/rest_day)
5. For premium: AI response generated in background, pushed via Realtime
6. For free: Template response returned immediately
7. End of day: remaining 'pending' check-ins marked as 'missed'
"""

from fastapi import APIRouter, HTTPException, status, Depends, Query
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime, date, timedelta
from app.core.flexible_auth import get_current_user
from app.services.logger import logger
import pytz

router = APIRouter(redirect_slashes=False)


# =============================================================================
# V2 PYDANTIC MODELS
# =============================================================================

# V2 Mood values (for completed check-ins)
VALID_MOODS = ["tough", "good", "amazing"]

# V2 Skip reasons (for skipped check-ins)
VALID_SKIP_REASONS = ["work", "tired", "sick", "schedule", "other"]

# V2.1 Check-in statuses
VALID_STATUSES = ["pending", "completed", "skipped", "missed", "rest_day"]


class CheckInCreate(BaseModel):
    """
    V2 Check-in creation model.

    Used when user responds to a notification or checks in manually.
    """

    goal_id: str
    completed: bool
    is_rest_day: Optional[bool] = False
    mood: Optional[str] = None  # tough, good, amazing (for completed)
    skip_reason: Optional[str] = None  # work, tired, sick, schedule, other (for missed)
    note: Optional[str] = None  # Optional reflection


class CheckInUpdate(BaseModel):
    """V2 Check-in update model."""

    completed: Optional[bool] = None
    is_rest_day: Optional[bool] = None
    mood: Optional[str] = None
    skip_reason: Optional[str] = None
    note: Optional[str] = None


class CheckInResponse(BaseModel):
    """
    V2 Check-in response model.
    status is the single source of truth - no completed/is_rest_day columns.
    """

    id: str
    goal_id: str
    user_id: str
    check_in_date: str
    status: str = "pending"  # pending, completed, skipped, missed, rest_day
    mood: Optional[str] = None
    skip_reason: Optional[str] = None
    note: Optional[str] = None
    ai_response: Optional[str] = None  # Generated by AI after check-in
    created_at: str
    updated_at: Optional[str] = None
    # Streak info (populated on create)
    current_streak: Optional[int] = None
    week_completions: Optional[int] = None  # For weekly goals: X/Y this week

    model_config = {"from_attributes": True}


class CheckInStats(BaseModel):
    """Check-in statistics."""

    total_checkins: int
    completed_checkins: int
    completion_rate: float
    current_streak: int
    longest_streak: int
    checkins_last_7d: int
    checkins_last_30d: int


class StreakInfo(BaseModel):
    """Streak information."""

    current_streak: int
    longest_streak: int
    last_check_in: Optional[str] = None
    streak_start: Optional[str] = None


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================


def get_user_today(user_timezone: str) -> date:
    """Get today's date in user's timezone."""
    try:
        user_tz = pytz.timezone(user_timezone)
        return datetime.now(user_tz).date()
    except Exception:
        return datetime.utcnow().date()


def get_user_day_of_week(user_timezone: str) -> int:
    """Get current day of week (0=Sunday) in user's timezone."""
    try:
        user_tz = pytz.timezone(user_timezone)
        user_now = datetime.now(user_tz)
        return (user_now.weekday() + 1) % 7  # Convert to 0=Sun
    except Exception:
        now = datetime.utcnow()
        return (now.weekday() + 1) % 7


# =============================================================================
# CHECK-IN ENDPOINTS
# =============================================================================


@router.post("", response_model=CheckInResponse, status_code=status.HTTP_201_CREATED)
async def create_check_in(
    checkin_data: CheckInCreate,
    current_user: dict = Depends(get_current_user),
):
    """
    V2: Create a check-in for a goal.

    This is the core endpoint called when:
    - User taps Yes/No/Rest Day on notification
    - User manually checks in from the app

    Flow:
    1. Validate goal ownership and status
    2. Create check-in record (without ai_response for premium)
    3. Queue background task to generate AI response (premium only)
    4. For free users, return template response immediately
    5. Update streak in background
    6. Notify partners
    7. Check achievements
    """
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()
    user_id = current_user["id"]
    user_timezone = current_user.get("timezone", "UTC")
    user_plan = current_user.get("plan", "free")

    # Verify goal belongs to user and is active
    goal = (
        supabase.table("goals")
        .select("*")
        .eq("id", checkin_data.goal_id)
        .eq("user_id", user_id)
        .maybe_single()
        .execute()
    )

    if not goal or not goal.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found"
        )

    goal_data = goal.data

    if goal_data.get("status") != "active":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot check in to an inactive goal",
        )

    # Get today's date in user's timezone
    user_today = get_user_today(user_timezone)

    # Validate that today is a scheduled day for this goal
    frequency_type = goal_data.get("frequency_type", "daily")
    target_days = goal_data.get("target_days") or []

    if frequency_type == "weekly" and target_days:
        user_day_of_week = get_user_day_of_week(user_timezone)
        if user_day_of_week not in target_days:
            # Map day number to name for user-friendly message
            day_names = [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
            today_name = day_names[user_day_of_week]
            scheduled_days = [day_names[d] for d in sorted(target_days)]
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Cannot check in on {today_name}. This goal is scheduled for: {', '.join(scheduled_days)}",
            )

    # Check if check-in exists for today (should be pre-created with status='pending')
    existing_checkin = (
        supabase.table("check_ins")
        .select("id, status")
        .eq("goal_id", checkin_data.goal_id)
        .eq("user_id", user_id)
        .eq("check_in_date", user_today.isoformat())
        .maybe_single()
        .execute()
    )

    if existing_checkin and existing_checkin.data:
        existing = existing_checkin.data
        # Already responded (not pending) - can't check in again
        if existing.get("status") and existing.get("status") != "pending":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You have already responded to your check-in for today",
            )

    # Validate mood if provided
    if checkin_data.mood and checkin_data.mood not in VALID_MOODS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid mood. Must be one of: {', '.join(VALID_MOODS)}",
        )

    # Validate skip_reason if provided
    if checkin_data.skip_reason and checkin_data.skip_reason not in VALID_SKIP_REASONS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid skip_reason. Must be one of: {', '.join(VALID_SKIP_REASONS)}",
        )

    # Determine status based on response
    if checkin_data.is_rest_day:
        checkin_status = "rest_day"
    elif checkin_data.completed:
        checkin_status = "completed"
    else:
        checkin_status = "skipped"  # Explicit "No" with optional skip_reason

    # Build check-in data
    # V2: Only store status - no completed/is_rest_day columns
    checkin = {
        "goal_id": checkin_data.goal_id,
        "user_id": user_id,
        "check_in_date": user_today.isoformat(),
        "status": checkin_status,
        "mood": checkin_data.mood,
        "skip_reason": checkin_data.skip_reason,
        "note": checkin_data.note.strip() if checkin_data.note else None,
    }

    # Determine if user gets AI check-in response feature
    from app.services.subscription_service import has_user_feature

    has_ai_checkin_response = await has_user_feature(
        supabase, user_id, "ai_checkin_response"
    )

    # For users WITHOUT ai_checkin_response: Generate template response immediately
    # For users WITH ai_checkin_response: AI response generated in background task
    if not has_ai_checkin_response:
        try:
            from app.services.motivation_service import get_template_response

            template_response = get_template_response(
                user_name=current_user.get("name", "there"),
                completed=checkin_data.completed,
                is_rest_day=checkin_data.is_rest_day or False,
                current_streak=goal_data.get("current_streak", 0),
                motivation_style=current_user.get("motivation_style", "supportive"),
            )
            checkin["ai_response"] = template_response
        except ImportError:
            # Service not available, use fallback
            if checkin_data.completed:
                checkin["ai_response"] = (
                    f"Great job, {current_user.get('name', 'there')}! Keep up the consistency! ðŸ’ª"
                )
            elif checkin_data.is_rest_day:
                checkin["ai_response"] = (
                    f"Rest well, {current_user.get('name', 'there')}! Recovery is part of the journey. ðŸ§˜"
                )
            else:
                checkin["ai_response"] = (
                    f"It's okay, {current_user.get('name', 'there')}. Tomorrow is a new chance! ðŸ’™"
                )
        except Exception as e:
            logger.warning(f"Failed to generate template response: {e}")

    # Update existing pending check-in or create new one
    if existing_checkin and existing_checkin.data:
        # Update the pre-created pending check-in
        result = (
            supabase.table("check_ins")
            .update(checkin)
            .eq("id", existing_checkin.data["id"])
            .execute()
        )
    else:
        # Edge case: No pending check-in exists (trigger didn't fire, goal just created, etc.)
        # Create a new check-in with the response status
        result = supabase.table("check_ins").insert(checkin).execute()

    if not result.data:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save check-in",
        )

    created_checkin = result.data[0]

    # For users WITH ai_checkin_response feature: Queue background task to generate AI response
    if has_ai_checkin_response:
        try:
            from app.services.tasks.motivation_tasks import generate_checkin_ai_response

            generate_checkin_ai_response.delay(
                checkin_id=created_checkin["id"],
                user_id=user_id,
                goal_id=checkin_data.goal_id,
            )
        except ImportError:
            logger.debug("Motivation tasks not available yet")
        except Exception as e:
            logger.warning(f"Failed to queue AI response task: {e}")

    # O(1) Streak Update - Update goal stats directly
    # Both daily and weekly goals increment streak on each scheduled day completion
    # Streak = consecutive scheduled days of completing (same logic for both types)
    try:
        goal_updates = {"last_checkin_date": user_today.isoformat()}
        new_streak = goal_data.get("current_streak", 0)
        is_weekly_goal = goal_data.get("frequency_type") == "weekly"

        if checkin_data.is_rest_day:
            # Rest day: preserve streak, don't count as completion
            pass
        elif checkin_data.completed:
            # Success: increment streak (same for daily AND weekly goals)
            new_streak = goal_data.get("current_streak", 0) + 1
            goal_updates["current_streak"] = new_streak
            goal_updates["longest_streak"] = max(
                goal_data.get("longest_streak", 0), new_streak
            )
            goal_updates["last_completed_date"] = user_today.isoformat()
            goal_updates["total_completions"] = (
                goal_data.get("total_completions", 0) + 1
            )

            # Set streak start if this is first day of streak
            if goal_data.get("current_streak", 0) == 0:
                goal_updates["streak_start_date"] = user_today.isoformat()

            # For weekly goals: also track week_completions for "X/Y this week" display
            if is_weekly_goal:
                week_start = user_today - timedelta(days=user_today.weekday())
                current_week_start = goal_data.get("week_start_date")

                if current_week_start != str(week_start):
                    # New week - reset counter
                    goal_updates["week_completions"] = 1
                    goal_updates["week_start_date"] = str(week_start)
                else:
                    goal_updates["week_completions"] = (
                        goal_data.get("week_completions", 0) + 1
                    )
        else:
            # Explicit "No" - break streak (both daily and weekly)
            goal_updates["current_streak"] = 0
            goal_updates["streak_start_date"] = None
            new_streak = 0

        # Single UPDATE query - O(1)
        supabase.table("goals").update(goal_updates).eq(
            "id", checkin_data.goal_id
        ).execute()

        # Update created_checkin with streak info for response
        created_checkin["current_streak"] = new_streak
        if is_weekly_goal:
            created_checkin["week_completions"] = goal_updates.get(
                "week_completions", goal_data.get("week_completions", 0)
            )

    except Exception as e:
        logger.warning(f"Failed to update goal streak: {e}")

    # Note: Partner notification is now handled by DB trigger
    # (018_checkin_partner_notification_trigger.sql)

    # Streak milestone celebration notification (fire-and-forget, non-blocking)
    # When user hits a milestone (7, 14, 21, 30, 50, 100, etc.), send celebration
    if checkin_data.completed and new_streak > 0:
        STREAK_MILESTONES = [7, 14, 21, 30, 50, 100, 200, 365, 500, 730, 1000]
        if new_streak in STREAK_MILESTONES:
            try:
                from app.services.tasks.notification_tasks import (
                    send_streak_milestone_notification,
                )

                goal_title = goal_data.get("title", "your goal")

                # Fire-and-forget: Queue to Celery so user doesn't wait
                send_streak_milestone_notification.delay(
                    user_id=user_id,
                    goal_id=checkin_data.goal_id,
                    goal_title=goal_title,
                    streak=new_streak,
                )
                logger.info(
                    f"Queued streak milestone notification: {new_streak} days for user {user_id}"
                )
            except Exception as e:
                logger.warning(f"Failed to queue streak milestone notification: {e}")

    # Check achievements in background
    if checkin_data.completed:
        try:
            from app.services.tasks import check_achievements_task

            check_achievements_task.delay(
                user_id=user_id,
                source_type="checkin",
                source_id=created_checkin["id"],
            )
        except Exception as e:
            logger.warning(f"Failed to queue achievement check: {e}")

    # Invalidate analytics cache for this goal (fire-and-forget)
    try:
        from app.services.tasks.analytics_refresh_tasks import (
            invalidate_user_analytics_cache,
        )

        invalidate_user_analytics_cache(user_id, str(checkin_data.goal_id))
    except Exception:
        pass  # Non-critical

    return created_checkin


@router.get("", response_model=List[CheckInResponse])
async def get_check_ins(
    current_user: dict = Depends(get_current_user),
    goal_id: Optional[str] = Query(None, description="Filter by goal ID"),
    start_date: Optional[date] = Query(None, description="Filter from date"),
    end_date: Optional[date] = Query(None, description="Filter to date"),
    exclude_pending: bool = Query(
        False, description="Exclude pending check-ins (for history views)"
    ),
    limit: int = Query(30, ge=1, le=100),
    offset: int = Query(0, ge=0),
):
    """Get user's check-ins with optional filtering."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    query = supabase.table("check_ins").select("*").eq("user_id", current_user["id"])

    if goal_id:
        query = query.eq("goal_id", goal_id)
    if start_date:
        query = query.gte("check_in_date", start_date.isoformat())
    if end_date:
        query = query.lte("check_in_date", end_date.isoformat())
    if exclude_pending:
        query = query.neq("status", "pending")

    result = (
        query.order("check_in_date", desc=True)
        .range(offset, offset + limit - 1)
        .execute()
    )

    return result.data or []


@router.get("/today", response_model=List[CheckInResponse])
async def get_today_check_ins(current_user: dict = Depends(get_current_user)):
    """Get all of today's check-ins for the user."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()
    user_timezone = current_user.get("timezone", "UTC")
    user_today = get_user_today(user_timezone)

    result = (
        supabase.table("check_ins")
        .select("*")
        .eq("user_id", current_user["id"])
        .eq("check_in_date", user_today.isoformat())
        .execute()
    )

    return result.data or []


@router.get("/goal/{goal_id}/today")
async def get_goal_today_status(
    goal_id: str,
    current_user: dict = Depends(get_current_user),
):
    """
    Get today's check-in status for a specific goal.

    Returns:
    - has_checked_in: whether user has checked in today
    - check_in: the check-in data if exists
    - can_check_in: whether user can check in (goal is active, scheduled for today)
    """
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()
    user_id = current_user["id"]
    user_timezone = current_user.get("timezone", "UTC")

    # Verify goal belongs to user
    goal = (
        supabase.table("goals")
        .select("*")
        .eq("id", goal_id)
        .eq("user_id", user_id)
        .maybe_single()
        .execute()
    )

    if not goal or not goal.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found"
        )

    goal_data = goal.data
    user_today = get_user_today(user_timezone)
    user_day_of_week = get_user_day_of_week(user_timezone)

    # Check if today is a scheduled day
    frequency_type = goal_data.get("frequency_type", "daily")
    target_days = goal_data.get("target_days") or []

    is_scheduled_today = False
    if frequency_type == "daily":
        is_scheduled_today = True
    elif target_days:
        is_scheduled_today = user_day_of_week in target_days

    # Check if user has checked in today
    checkin = (
        supabase.table("check_ins")
        .select("*")
        .eq("goal_id", goal_id)
        .eq("user_id", user_id)
        .eq("check_in_date", user_today.isoformat())
        .maybe_single()
        .execute()
    )

    has_checked_in = checkin.data is not None
    can_check_in = goal_data.get("status") == "active" and is_scheduled_today

    return {
        "goal_id": goal_id,
        "date": user_today.isoformat(),
        "has_checked_in": has_checked_in,
        "check_in": checkin.data,
        "can_check_in": can_check_in,
        "is_scheduled_today": is_scheduled_today,
    }


@router.get("/stats", response_model=CheckInStats)
async def get_check_in_stats(
    current_user: dict = Depends(get_current_user),
    goal_id: Optional[str] = Query(None, description="Filter by goal ID"),
):
    """Get check-in statistics for user or specific goal."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    query = supabase.table("check_ins").select("*").eq("user_id", current_user["id"])

    if goal_id:
        query = query.eq("goal_id", goal_id)

    result = query.execute()
    checkins = result.data or []

    # V2.1: Exclude pending check-ins from total count
    total_checkins = len([c for c in checkins if c.get("status") != "pending"])
    # V2.1: Use status field instead of completed boolean
    completed_checkins = len([c for c in checkins if c.get("status") == "completed"])
    completion_rate = (
        round(completed_checkins / total_checkins * 100, 1) if total_checkins > 0 else 0
    )

    # Calculate streaks - V2.1: Use status field
    sorted_checkins = sorted(
        [c for c in checkins if c.get("status") == "completed"],
        key=lambda x: x["check_in_date"],
        reverse=True,
    )

    current_streak = 0
    longest_streak = 0
    temp_streak = 0

    for i, checkin in enumerate(sorted_checkins):
        if i == 0:
            temp_streak = 1
            current_streak = 1
        else:
            prev_date = datetime.fromisoformat(
                sorted_checkins[i - 1]["check_in_date"]
            ).date()
            curr_date = datetime.fromisoformat(checkin["check_in_date"]).date()
            if (prev_date - curr_date).days == 1:
                temp_streak += 1
                if i == len(sorted_checkins) - 1 or current_streak == temp_streak - 1:
                    current_streak = temp_streak
            else:
                longest_streak = max(longest_streak, temp_streak)
                temp_streak = 1

    longest_streak = max(longest_streak, temp_streak)

    # Last 7 and 30 days
    today = datetime.utcnow().date()
    week_ago = today - timedelta(days=7)
    month_ago = today - timedelta(days=30)

    # V2.1: Use status field
    checkins_7d = len(
        [
            c
            for c in checkins
            if c.get("status") == "completed"
            and c.get("check_in_date") >= week_ago.isoformat()
        ]
    )
    checkins_30d = len(
        [
            c
            for c in checkins
            if c.get("status") == "completed"
            and c.get("check_in_date") >= month_ago.isoformat()
        ]
    )

    return CheckInStats(
        total_checkins=total_checkins,
        completed_checkins=completed_checkins,
        completion_rate=completion_rate,
        current_streak=current_streak,
        longest_streak=longest_streak,
        checkins_last_7d=checkins_7d,
        checkins_last_30d=checkins_30d,
    )


@router.get("/streak", response_model=StreakInfo)
async def get_streak_info(
    current_user: dict = Depends(get_current_user),
    goal_id: Optional[str] = Query(None, description="Filter by goal ID"),
):
    """Get streak information for user or specific goal."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()
    user_id = current_user["id"]

    if goal_id:
        # Get streak from the goal directly (V2 stores streaks on goal)
        goal = (
            supabase.table("goals")
            .select("current_streak, longest_streak")
            .eq("id", goal_id)
            .eq("user_id", user_id)
            .maybe_single()
            .execute()
        )

        if not goal or not goal.data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Goal not found"
            )

        # Get last check-in date (V2: use status instead of completed)
        last_checkin = (
            supabase.table("check_ins")
            .select("check_in_date")
            .eq("goal_id", goal_id)
            .eq("status", "completed")
            .order("check_in_date", desc=True)
            .limit(1)
            .execute()
        )

        return StreakInfo(
            current_streak=goal.data.get("current_streak", 0),
            longest_streak=goal.data.get("longest_streak", 0),
            last_check_in=(
                last_checkin.data[0]["check_in_date"] if last_checkin.data else None
            ),
            streak_start=None,
        )
    else:
        # Get best streak across all goals
        goals = (
            supabase.table("goals")
            .select("current_streak, longest_streak")
            .eq("user_id", user_id)
            .execute()
        )

        goals_data = goals.data or []
        current_streak = max(
            (g.get("current_streak", 0) for g in goals_data), default=0
        )
        longest_streak = max(
            (g.get("longest_streak", 0) for g in goals_data), default=0
        )

        # Get last check-in date across all goals (V2: use status)
        last_checkin = (
            supabase.table("check_ins")
            .select("check_in_date")
            .eq("user_id", user_id)
            .eq("status", "completed")
            .order("check_in_date", desc=True)
            .limit(1)
            .execute()
        )

        return StreakInfo(
            current_streak=current_streak,
            longest_streak=longest_streak,
            last_check_in=(
                last_checkin.data[0]["check_in_date"] if last_checkin.data else None
            ),
            streak_start=None,
        )


@router.get("/calendar")
async def get_check_in_calendar(
    current_user: dict = Depends(get_current_user),
    year: Optional[int] = Query(None),
    month: Optional[int] = Query(None),
    goal_id: Optional[str] = Query(None),
):
    """Get check-ins in calendar format for a specific month."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    # Default to current month
    if not year or not month:
        now = datetime.now()
        year = now.year
        month = now.month

    # Get first and last day of month
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = date(year, month + 1, 1) - timedelta(days=1)

    # V2: Select status instead of completed/is_rest_day
    query = (
        supabase.table("check_ins")
        .select("id, goal_id, check_in_date, status, mood")
        .eq("user_id", current_user["id"])
        .gte("check_in_date", start_date.isoformat())
        .lte("check_in_date", end_date.isoformat())
    )

    if goal_id:
        query = query.eq("goal_id", goal_id)

    result = query.execute()

    # Group by date
    calendar_data = {}
    for checkin in result.data or []:
        checkin_date = checkin["check_in_date"]
        if checkin_date not in calendar_data:
            calendar_data[checkin_date] = []
        calendar_data[checkin_date].append(checkin)

    return {
        "year": year,
        "month": month,
        "days": calendar_data,
    }


@router.get("/{checkin_id}", response_model=CheckInResponse)
async def get_check_in(
    checkin_id: str,
    current_user: dict = Depends(get_current_user),
):
    """Get a specific check-in by ID."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    result = (
        supabase.table("check_ins")
        .select("*")
        .eq("id", checkin_id)
        .eq("user_id", current_user["id"])
        .maybe_single()
        .execute()
    )

    if not result or not result.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Check-in not found"
        )

    return result.data


@router.put("/{checkin_id}", response_model=CheckInResponse)
async def update_check_in(
    checkin_id: str,
    checkin_data: CheckInUpdate,
    current_user: dict = Depends(get_current_user),
):
    """Update a check-in."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    # Check if check-in exists and belongs to user
    existing = (
        supabase.table("check_ins")
        .select("*")
        .eq("id", checkin_id)
        .eq("user_id", current_user["id"])
        .maybe_single()
        .execute()
    )

    if not existing or not existing.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Check-in not found"
        )

    update_data = {k: v for k, v in checkin_data.dict().items() if v is not None}

    # Validate mood if provided
    if "mood" in update_data and update_data["mood"] not in VALID_MOODS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid mood. Must be one of: {', '.join(VALID_MOODS)}",
        )

    # Validate skip_reason if provided
    if (
        "skip_reason" in update_data
        and update_data["skip_reason"] not in VALID_SKIP_REASONS
    ):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid skip_reason. Must be one of: {', '.join(VALID_SKIP_REASONS)}",
        )

    if update_data:
        supabase.table("check_ins").update(update_data).eq("id", checkin_id).execute()

    # Get updated check-in
    result = supabase.table("check_ins").select("*").eq("id", checkin_id).execute()

    updated_checkin = result.data[0]

    # If marking as completed, check achievements
    if update_data.get("completed"):
        try:
            from app.services.tasks import check_achievements_task

            check_achievements_task.delay(
                user_id=current_user["id"],
                source_type="checkin",
                source_id=checkin_id,
            )
        except Exception as e:
            logger.warning(f"Failed to queue achievement check: {e}")

    # Note: Partner notification is now handled by DB trigger
    # (018_checkin_partner_notification_trigger.sql)

    # Invalidate analytics cache for this goal (fire-and-forget)
    try:
        from app.services.tasks.analytics_refresh_tasks import (
            invalidate_user_analytics_cache,
        )

        invalidate_user_analytics_cache(
            current_user["id"], existing.data.get("goal_id")
        )
    except Exception:
        pass  # Non-critical

    return updated_checkin


@router.delete("/{checkin_id}")
async def delete_check_in(
    checkin_id: str,
    current_user: dict = Depends(get_current_user),
):
    """Delete a check-in."""
    from app.core.database import get_supabase_client

    supabase = get_supabase_client()

    # Check if check-in exists and belongs to user
    existing = (
        supabase.table("check_ins")
        .select("id, goal_id")
        .eq("id", checkin_id)
        .eq("user_id", current_user["id"])
        .maybe_single()
        .execute()
    )

    if not existing or not existing.data:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Check-in not found"
        )

    # Get goal_id before deletion for cache invalidation
    goal_id = existing.data.get("goal_id")

    # Delete the check-in
    # Note: Goal stats (streaks, completions) are automatically updated
    # by the database trigger 'trigger_checkin_delete_goal_sync'
    supabase.table("check_ins").delete().eq("id", checkin_id).execute()

    # Note: Partner notification is now handled by DB trigger
    # (018_checkin_partner_notification_trigger.sql)

    # Invalidate analytics cache for this goal (fire-and-forget)
    try:
        from app.services.tasks.analytics_refresh_tasks import (
            invalidate_user_analytics_cache,
        )

        invalidate_user_analytics_cache(current_user["id"], goal_id)
    except Exception:
        pass  # Non-critical

    return {"message": "Check-in deleted successfully"}
